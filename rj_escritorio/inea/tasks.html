<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pipelines.rj_escritorio.inea.tasks API documentation</title>
<meta name="description" content="Tasks for INEA." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pipelines.rj_escritorio.inea.tasks</code></h1>
</header>
<section id="section-intro">
<p>Tasks for INEA.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Tasks for INEA.
&#34;&#34;&#34;
from datetime import datetime, timedelta
from functools import partial
from os import environ, getenv
from pathlib import Path
import subprocess
from typing import Callable, List, Tuple

from google.cloud import storage
from paramiko import SSHClient
import pexpect
from prefect import task
from scp import SCPClient

from pipelines.utils.utils import get_credentials_from_env, list_blobs_with_prefix, log


@task
def print_environment_variables():
    &#34;&#34;&#34;
    Print all environment variables
    &#34;&#34;&#34;
    log(&#34;Environment variables:&#34;)
    for key, value in environ.items():
        log(f&#34;{key}={value}&#34;)


@task(
    nout=2,
    max_retries=2,
    retry_delay=timedelta(seconds=10),
)
# pylint: disable=too-many-arguments,too-many-locals
def list_vol_files(
    bucket_name: str,
    prefix: str,
    radar: str,
    product: str,
    date: str = None,
    greater_than: str = None,
    mode: str = &#34;prod&#34;,
    output_format: str = &#34;NetCDF&#34;,
    output_directory: str = &#34;/var/escritoriodedados/temp/&#34;,
    vols_remote_directory: str = &#34;/var/opt/edge/vols&#34;,
) -&gt; Tuple[List[str], str]:
    &#34;&#34;&#34;
    List files from INEA server

    Args:
        date (str): Date of the files to be fetched (e.g. 20220125)
        greater_than (str): Fetch files with a date greater than this one
        output_directory (str): Directory where the files will be saved
    &#34;&#34;&#34;

    # If none of `date` or `greater_than` are provided, find blob with the latest date
    if date is None and greater_than is None:
        log(&#34;No date or greater_than provided. Finding latest blob...&#34;)
        # First, we build the search prefix
        search_prefix = f&#34;{prefix}/radar={radar}/produto={product}&#34;
        # Then, we add the current date partition
        current_date = datetime.now()
        current_date_str = current_date.strftime(&#34;%Y-%m-%d&#34;)
        today_blobs = list_blobs_with_prefix(
            bucket_name=bucket_name,
            prefix=f&#34;{search_prefix}/data_particao={current_date_str}&#34;,
            mode=mode,
        )
        log(
            f&#34;Searched for blobs with prefix {search_prefix}/data_particao={current_date_str}&#34;
        )
        # Next, we get past day blobs
        past_date = current_date - timedelta(days=1)
        past_date_str = past_date.strftime(&#34;%Y-%m-%d&#34;)
        past_blobs = list_blobs_with_prefix(
            bucket_name=bucket_name,
            prefix=f&#34;{search_prefix}/data_particao={past_date_str}&#34;,
            mode=mode,
        )
        log(
            f&#34;Searched for blobs with prefix {search_prefix}/data_particao={past_date_str}&#34;
        )
        # Then, we merge the two lists
        blobs = today_blobs + past_blobs
        # Now, we sort it by `blob.name`
        blobs.sort(key=lambda blob: blob.name)
        # Finally, we get the latest blob
        latest_blob = blobs[-1]
        log(f&#34;Latest blob found: {latest_blob.name}&#34;)
        # And we get the greater_than from its name (differs for every output_format)
        if output_format == &#34;NetCDF&#34;:
            # Format of the name is 9921GUA-20221017-070010-PPIVol-0000.nc.gz
            # We need to join 20221017 and 070010
            fname = latest_blob.name.split(&#34;/&#34;)[-1]
            greater_than = fname.split(&#34;-&#34;)[1] + fname.split(&#34;-&#34;)[2]
        elif output_format == &#34;HDF5&#34;:
            # Format of the name is 9921GUA-PPIVol-20220930-121010-0004.hdf
            # We need to join 20220930 and 121010
            fname = latest_blob.name.split(&#34;/&#34;)[-1]
            greater_than = fname.split(&#34;-&#34;)[2] + fname.split(&#34;-&#34;)[3]
        log(f&#34;Latest blob date: {greater_than}&#34;)

    # Creating temporary directory
    if date:
        output_directory_path = Path(output_directory) / date
    else:
        output_directory_path = Path(output_directory) / f&#34;greaterthan-{greater_than}&#34;
    output_directory_path.mkdir(parents=True, exist_ok=True)
    log(f&#34;Temporary directory created: {output_directory_path}&#34;)

    # Get SSH password from env
    ssh_password = getenv(&#34;INEA_SSH_PASSWORD&#34;)

    # Open SSH client
    ssh_client = SSHClient()
    ssh_client.load_system_host_keys()
    ssh_client.connect(hostname=&#34;a9921&#34;, username=&#34;root&#34;, password=ssh_password)

    # List remote files
    log(&#34;Listing remote files...&#34;)
    if date:
        _, stdout, _ = ssh_client.exec_command(
            f&#34;find {vols_remote_directory} -name &#39;9921GUA{date}*.vol&#39;&#34;
        )
        remote_files = stdout.read().decode(&#34;utf-8&#34;).splitlines()
    else:
        _, stdout, _ = ssh_client.exec_command(
            f&#34;find {vols_remote_directory} -name &#39;9921GUA*.vol&#39;&#34;
        )
        all_files = stdout.read().decode(&#34;utf-8&#34;).splitlines()
        remote_files = [
            file
            for file in all_files
            if file.split(&#34;/&#34;)[-1][: len(greater_than) + 7] &gt;= f&#34;9921GUA{greater_than}&#34;
        ]
    log(f&#34;Found {len(remote_files)} files.&#34;)
    log(f&#34;Remote files: {remote_files}&#34;)
    return remote_files, output_directory_path


@task(
    max_retries=2,
    retry_delay=timedelta(seconds=30),
)
def fetch_vol_file(
    remote_file: str,
    output_directory: str = &#34;/var/escritoriodedados/temp/&#34;,
):
    &#34;&#34;&#34;
    Fetch files from INEA server

    Args:
        remote_file (str): Remote file to be fetched
        output_directory (str): Directory where the files will be saved
    &#34;&#34;&#34;
    # Get SSH password from env
    ssh_password = getenv(&#34;INEA_SSH_PASSWORD&#34;)

    # Open SSH client
    ssh_client = SSHClient()
    ssh_client.load_system_host_keys()
    ssh_client.connect(hostname=&#34;a9921&#34;, username=&#34;root&#34;, password=ssh_password)

    # Open SCP client
    scp = SCPClient(ssh_client.get_transport(), sanitize=lambda x: x)

    # Fetch VOL file
    scp.get(remote_file, local_path=str(output_directory))

    # Close connection
    scp.close()

    # Return local file path
    return Path(output_directory) / remote_file.split(&#34;/&#34;)[-1]


@task
def convert_vol_file(
    downloaded_file: str,
    output_format: str = &#34;NetCDF&#34;,
    convert_params: str = &#34;-f=Whole -k=CFext -r=Short -p=Radar -M=All -z&#34;,
) -&gt; List[str]:
    &#34;&#34;&#34;
    Convert VOL files to NetCDF using the `volconvert` CLI tool.
    &#34;&#34;&#34;
    # Run volconvert
    log(f&#34;Converting file {downloaded_file} to {output_format}...&#34;)
    command = (
        f&#39;/opt/edge/bin/volconvert {downloaded_file} &#34;{output_format}.&#39;
        + &#34;{&#34;
        + convert_params
        + &#39;}&#34;&#39;
    )
    log(f&#34;Running command: {command}&#34;)
    child = pexpect.spawn(command)
    try:
        log(f&#34;before expect {str(child)}&#34;)
        # Look for the &#34;OutFiles:...&#34; row and get only that row
        child.expect(&#34;OutFiles:(.*)\n&#34;)
        # Get the output file name
        log(f&#34;after expect {str(child)}&#34;)
        converted_file = child.match.group(1).decode(&#34;utf-8&#34;).strip()
        log(f&#34;after match.group expect {str(child)}&#34;)
        # Log the output file name
        log(f&#34;Output file: {converted_file}&#34;)
        # Go to the end of the command log
        child.expect(pexpect.EOF)
    except Exception as exc:
        # Log the error
        log(child.before.decode(&#34;utf-8&#34;))
        raise exc
    # Delete the VOL file
    Path(downloaded_file).unlink()
    # Return the name of the converted file
    return converted_file


@task(
    max_retries=3,
    retry_delay=timedelta(seconds=30),
)
# pylint: disable=too-many-arguments, too-many-locals
def upload_file_to_gcs(
    converted_file: str,
    bucket_name: str,
    prefix: str,
    radar: str,
    product: str,
    mode=&#34;prod&#34;,
    task_mode=&#34;partitioned&#34;,
    unlink: bool = True,
):
    &#34;&#34;&#34;
    Upload files to GCS
    &#34;&#34;&#34;
    credentials = get_credentials_from_env(mode=mode)
    storage_client = storage.Client(credentials=credentials)

    bucket = storage_client.bucket(bucket_name)

    file = Path(converted_file)
    if file.is_file():
        if task_mode == &#34;partitioned&#34;:
            # Converted file path is in the format:
            # /var/opt/edge/.../YYYYMMDD/&lt;filename&gt;.nc.gz
            # We need to get the datetime for the file
            date_str = file.parent.name
            date = datetime.strptime(date_str, &#34;%Y%m%d&#34;).strftime(&#34;%Y-%m-%d&#34;)
            blob_name = f&#34;{prefix}/radar={radar}/produto={product}/data_particao={date}/{file.name}&#34;
            blob_name = blob_name.replace(&#34;//&#34;, &#34;/&#34;)
        elif task_mode == &#34;raw&#34;:
            blob_name = f&#34;{prefix}/{file.name}&#34;
        else:
            raise ValueError(f&#34;Invalid task_mode: {task_mode}&#34;)
        log(f&#34;Uploading file {file} to GCS...&#34;)
        log(f&#34;Blob name will be {blob_name}&#34;)
        blob = bucket.blob(blob_name)
        blob.upload_from_filename(file)
        log(f&#34;File {file} uploaded to GCS.&#34;)
        if unlink:
            file.unlink()


@task
def execute_shell_command(
    command: str,
    stdout_callback: Callable = log,
    stderr_callback: Callable = partial(log, level=&#34;error&#34;),
):
    &#34;&#34;&#34;
    Executes a shell command and logs output
    &#34;&#34;&#34;
    # pylint: disable=consider-using-with
    popen = subprocess.Popen(
        command,
        shell=True,
        stdout=subprocess.PIPE,
        universal_newlines=True,
        stderr=subprocess.PIPE,
    )
    for stdout_line in iter(popen.stdout.readline, &#34;&#34;):
        stdout_callback(stdout_line)
    for stderr_line in iter(popen.stderr.readline, &#34;&#34;):
        stderr_callback(stderr_line)
    popen.stdout.close()
    return_code = popen.wait()
    if return_code:
        log(f&#34;Command {command} failed with return code {return_code}&#34;, &#34;error&#34;)
    else:
        log(f&#34;Command {command} executed successfully&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pipelines.rj_escritorio.inea.tasks.convert_vol_file"><code class="name flex">
<span>def <span class="ident">convert_vol_file</span></span>(<span>downloaded_file:Â str, output_format:Â strÂ =Â 'NetCDF', convert_params:Â strÂ =Â '-f=Whole -k=CFext -r=Short -p=Radar -M=All -z') â€‘>Â List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert VOL files to NetCDF using the <code>volconvert</code> CLI tool.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@task
def convert_vol_file(
    downloaded_file: str,
    output_format: str = &#34;NetCDF&#34;,
    convert_params: str = &#34;-f=Whole -k=CFext -r=Short -p=Radar -M=All -z&#34;,
) -&gt; List[str]:
    &#34;&#34;&#34;
    Convert VOL files to NetCDF using the `volconvert` CLI tool.
    &#34;&#34;&#34;
    # Run volconvert
    log(f&#34;Converting file {downloaded_file} to {output_format}...&#34;)
    command = (
        f&#39;/opt/edge/bin/volconvert {downloaded_file} &#34;{output_format}.&#39;
        + &#34;{&#34;
        + convert_params
        + &#39;}&#34;&#39;
    )
    log(f&#34;Running command: {command}&#34;)
    child = pexpect.spawn(command)
    try:
        log(f&#34;before expect {str(child)}&#34;)
        # Look for the &#34;OutFiles:...&#34; row and get only that row
        child.expect(&#34;OutFiles:(.*)\n&#34;)
        # Get the output file name
        log(f&#34;after expect {str(child)}&#34;)
        converted_file = child.match.group(1).decode(&#34;utf-8&#34;).strip()
        log(f&#34;after match.group expect {str(child)}&#34;)
        # Log the output file name
        log(f&#34;Output file: {converted_file}&#34;)
        # Go to the end of the command log
        child.expect(pexpect.EOF)
    except Exception as exc:
        # Log the error
        log(child.before.decode(&#34;utf-8&#34;))
        raise exc
    # Delete the VOL file
    Path(downloaded_file).unlink()
    # Return the name of the converted file
    return converted_file</code></pre>
</details>
</dd>
<dt id="pipelines.rj_escritorio.inea.tasks.execute_shell_command"><code class="name flex">
<span>def <span class="ident">execute_shell_command</span></span>(<span>command:Â str, stdout_callback:Â CallableÂ =Â &lt;function log&gt;, stderr_callback:Â CallableÂ =Â functools.partial(&lt;function log&gt;, level=&#x27;error&#x27;))</span>
</code></dt>
<dd>
<div class="desc"><p>Executes a shell command and logs output</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@task
def execute_shell_command(
    command: str,
    stdout_callback: Callable = log,
    stderr_callback: Callable = partial(log, level=&#34;error&#34;),
):
    &#34;&#34;&#34;
    Executes a shell command and logs output
    &#34;&#34;&#34;
    # pylint: disable=consider-using-with
    popen = subprocess.Popen(
        command,
        shell=True,
        stdout=subprocess.PIPE,
        universal_newlines=True,
        stderr=subprocess.PIPE,
    )
    for stdout_line in iter(popen.stdout.readline, &#34;&#34;):
        stdout_callback(stdout_line)
    for stderr_line in iter(popen.stderr.readline, &#34;&#34;):
        stderr_callback(stderr_line)
    popen.stdout.close()
    return_code = popen.wait()
    if return_code:
        log(f&#34;Command {command} failed with return code {return_code}&#34;, &#34;error&#34;)
    else:
        log(f&#34;Command {command} executed successfully&#34;)</code></pre>
</details>
</dd>
<dt id="pipelines.rj_escritorio.inea.tasks.fetch_vol_file"><code class="name flex">
<span>def <span class="ident">fetch_vol_file</span></span>(<span>remote_file:Â str, output_directory:Â strÂ =Â '/var/escritoriodedados/temp/')</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch files from INEA server</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>remote_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Remote file to be fetched</dd>
<dt><strong><code>output_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>Directory where the files will be saved</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@task(
    max_retries=2,
    retry_delay=timedelta(seconds=30),
)
def fetch_vol_file(
    remote_file: str,
    output_directory: str = &#34;/var/escritoriodedados/temp/&#34;,
):
    &#34;&#34;&#34;
    Fetch files from INEA server

    Args:
        remote_file (str): Remote file to be fetched
        output_directory (str): Directory where the files will be saved
    &#34;&#34;&#34;
    # Get SSH password from env
    ssh_password = getenv(&#34;INEA_SSH_PASSWORD&#34;)

    # Open SSH client
    ssh_client = SSHClient()
    ssh_client.load_system_host_keys()
    ssh_client.connect(hostname=&#34;a9921&#34;, username=&#34;root&#34;, password=ssh_password)

    # Open SCP client
    scp = SCPClient(ssh_client.get_transport(), sanitize=lambda x: x)

    # Fetch VOL file
    scp.get(remote_file, local_path=str(output_directory))

    # Close connection
    scp.close()

    # Return local file path
    return Path(output_directory) / remote_file.split(&#34;/&#34;)[-1]</code></pre>
</details>
</dd>
<dt id="pipelines.rj_escritorio.inea.tasks.list_vol_files"><code class="name flex">
<span>def <span class="ident">list_vol_files</span></span>(<span>bucket_name:Â str, prefix:Â str, radar:Â str, product:Â str, date:Â strÂ =Â None, greater_than:Â strÂ =Â None, mode:Â strÂ =Â 'prod', output_format:Â strÂ =Â 'NetCDF', output_directory:Â strÂ =Â '/var/escritoriodedados/temp/', vols_remote_directory:Â strÂ =Â '/var/opt/edge/vols') â€‘>Â Tuple[List[str],Â str]</span>
</code></dt>
<dd>
<div class="desc"><p>List files from INEA server</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>date</code></strong> :&ensp;<code>str</code></dt>
<dd>Date of the files to be fetched (e.g. 20220125)</dd>
<dt><strong><code>greater_than</code></strong> :&ensp;<code>str</code></dt>
<dd>Fetch files with a date greater than this one</dd>
<dt><strong><code>output_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>Directory where the files will be saved</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@task(
    nout=2,
    max_retries=2,
    retry_delay=timedelta(seconds=10),
)
# pylint: disable=too-many-arguments,too-many-locals
def list_vol_files(
    bucket_name: str,
    prefix: str,
    radar: str,
    product: str,
    date: str = None,
    greater_than: str = None,
    mode: str = &#34;prod&#34;,
    output_format: str = &#34;NetCDF&#34;,
    output_directory: str = &#34;/var/escritoriodedados/temp/&#34;,
    vols_remote_directory: str = &#34;/var/opt/edge/vols&#34;,
) -&gt; Tuple[List[str], str]:
    &#34;&#34;&#34;
    List files from INEA server

    Args:
        date (str): Date of the files to be fetched (e.g. 20220125)
        greater_than (str): Fetch files with a date greater than this one
        output_directory (str): Directory where the files will be saved
    &#34;&#34;&#34;

    # If none of `date` or `greater_than` are provided, find blob with the latest date
    if date is None and greater_than is None:
        log(&#34;No date or greater_than provided. Finding latest blob...&#34;)
        # First, we build the search prefix
        search_prefix = f&#34;{prefix}/radar={radar}/produto={product}&#34;
        # Then, we add the current date partition
        current_date = datetime.now()
        current_date_str = current_date.strftime(&#34;%Y-%m-%d&#34;)
        today_blobs = list_blobs_with_prefix(
            bucket_name=bucket_name,
            prefix=f&#34;{search_prefix}/data_particao={current_date_str}&#34;,
            mode=mode,
        )
        log(
            f&#34;Searched for blobs with prefix {search_prefix}/data_particao={current_date_str}&#34;
        )
        # Next, we get past day blobs
        past_date = current_date - timedelta(days=1)
        past_date_str = past_date.strftime(&#34;%Y-%m-%d&#34;)
        past_blobs = list_blobs_with_prefix(
            bucket_name=bucket_name,
            prefix=f&#34;{search_prefix}/data_particao={past_date_str}&#34;,
            mode=mode,
        )
        log(
            f&#34;Searched for blobs with prefix {search_prefix}/data_particao={past_date_str}&#34;
        )
        # Then, we merge the two lists
        blobs = today_blobs + past_blobs
        # Now, we sort it by `blob.name`
        blobs.sort(key=lambda blob: blob.name)
        # Finally, we get the latest blob
        latest_blob = blobs[-1]
        log(f&#34;Latest blob found: {latest_blob.name}&#34;)
        # And we get the greater_than from its name (differs for every output_format)
        if output_format == &#34;NetCDF&#34;:
            # Format of the name is 9921GUA-20221017-070010-PPIVol-0000.nc.gz
            # We need to join 20221017 and 070010
            fname = latest_blob.name.split(&#34;/&#34;)[-1]
            greater_than = fname.split(&#34;-&#34;)[1] + fname.split(&#34;-&#34;)[2]
        elif output_format == &#34;HDF5&#34;:
            # Format of the name is 9921GUA-PPIVol-20220930-121010-0004.hdf
            # We need to join 20220930 and 121010
            fname = latest_blob.name.split(&#34;/&#34;)[-1]
            greater_than = fname.split(&#34;-&#34;)[2] + fname.split(&#34;-&#34;)[3]
        log(f&#34;Latest blob date: {greater_than}&#34;)

    # Creating temporary directory
    if date:
        output_directory_path = Path(output_directory) / date
    else:
        output_directory_path = Path(output_directory) / f&#34;greaterthan-{greater_than}&#34;
    output_directory_path.mkdir(parents=True, exist_ok=True)
    log(f&#34;Temporary directory created: {output_directory_path}&#34;)

    # Get SSH password from env
    ssh_password = getenv(&#34;INEA_SSH_PASSWORD&#34;)

    # Open SSH client
    ssh_client = SSHClient()
    ssh_client.load_system_host_keys()
    ssh_client.connect(hostname=&#34;a9921&#34;, username=&#34;root&#34;, password=ssh_password)

    # List remote files
    log(&#34;Listing remote files...&#34;)
    if date:
        _, stdout, _ = ssh_client.exec_command(
            f&#34;find {vols_remote_directory} -name &#39;9921GUA{date}*.vol&#39;&#34;
        )
        remote_files = stdout.read().decode(&#34;utf-8&#34;).splitlines()
    else:
        _, stdout, _ = ssh_client.exec_command(
            f&#34;find {vols_remote_directory} -name &#39;9921GUA*.vol&#39;&#34;
        )
        all_files = stdout.read().decode(&#34;utf-8&#34;).splitlines()
        remote_files = [
            file
            for file in all_files
            if file.split(&#34;/&#34;)[-1][: len(greater_than) + 7] &gt;= f&#34;9921GUA{greater_than}&#34;
        ]
    log(f&#34;Found {len(remote_files)} files.&#34;)
    log(f&#34;Remote files: {remote_files}&#34;)
    return remote_files, output_directory_path</code></pre>
</details>
</dd>
<dt id="pipelines.rj_escritorio.inea.tasks.print_environment_variables"><code class="name flex">
<span>def <span class="ident">print_environment_variables</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Print all environment variables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@task
def print_environment_variables():
    &#34;&#34;&#34;
    Print all environment variables
    &#34;&#34;&#34;
    log(&#34;Environment variables:&#34;)
    for key, value in environ.items():
        log(f&#34;{key}={value}&#34;)</code></pre>
</details>
</dd>
<dt id="pipelines.rj_escritorio.inea.tasks.upload_file_to_gcs"><code class="name flex">
<span>def <span class="ident">upload_file_to_gcs</span></span>(<span>converted_file:Â str, bucket_name:Â str, prefix:Â str, radar:Â str, product:Â str, mode='prod', task_mode='partitioned', unlink:Â boolÂ =Â True)</span>
</code></dt>
<dd>
<div class="desc"><p>Upload files to GCS</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@task(
    max_retries=3,
    retry_delay=timedelta(seconds=30),
)
# pylint: disable=too-many-arguments, too-many-locals
def upload_file_to_gcs(
    converted_file: str,
    bucket_name: str,
    prefix: str,
    radar: str,
    product: str,
    mode=&#34;prod&#34;,
    task_mode=&#34;partitioned&#34;,
    unlink: bool = True,
):
    &#34;&#34;&#34;
    Upload files to GCS
    &#34;&#34;&#34;
    credentials = get_credentials_from_env(mode=mode)
    storage_client = storage.Client(credentials=credentials)

    bucket = storage_client.bucket(bucket_name)

    file = Path(converted_file)
    if file.is_file():
        if task_mode == &#34;partitioned&#34;:
            # Converted file path is in the format:
            # /var/opt/edge/.../YYYYMMDD/&lt;filename&gt;.nc.gz
            # We need to get the datetime for the file
            date_str = file.parent.name
            date = datetime.strptime(date_str, &#34;%Y%m%d&#34;).strftime(&#34;%Y-%m-%d&#34;)
            blob_name = f&#34;{prefix}/radar={radar}/produto={product}/data_particao={date}/{file.name}&#34;
            blob_name = blob_name.replace(&#34;//&#34;, &#34;/&#34;)
        elif task_mode == &#34;raw&#34;:
            blob_name = f&#34;{prefix}/{file.name}&#34;
        else:
            raise ValueError(f&#34;Invalid task_mode: {task_mode}&#34;)
        log(f&#34;Uploading file {file} to GCS...&#34;)
        log(f&#34;Blob name will be {blob_name}&#34;)
        blob = bucket.blob(blob_name)
        blob.upload_from_filename(file)
        log(f&#34;File {file} uploaded to GCS.&#34;)
        if unlink:
            file.unlink()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pipelines.rj_escritorio.inea" href="index.html">pipelines.rj_escritorio.inea</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pipelines.rj_escritorio.inea.tasks.convert_vol_file" href="#pipelines.rj_escritorio.inea.tasks.convert_vol_file">convert_vol_file</a></code></li>
<li><code><a title="pipelines.rj_escritorio.inea.tasks.execute_shell_command" href="#pipelines.rj_escritorio.inea.tasks.execute_shell_command">execute_shell_command</a></code></li>
<li><code><a title="pipelines.rj_escritorio.inea.tasks.fetch_vol_file" href="#pipelines.rj_escritorio.inea.tasks.fetch_vol_file">fetch_vol_file</a></code></li>
<li><code><a title="pipelines.rj_escritorio.inea.tasks.list_vol_files" href="#pipelines.rj_escritorio.inea.tasks.list_vol_files">list_vol_files</a></code></li>
<li><code><a title="pipelines.rj_escritorio.inea.tasks.print_environment_variables" href="#pipelines.rj_escritorio.inea.tasks.print_environment_variables">print_environment_variables</a></code></li>
<li><code><a title="pipelines.rj_escritorio.inea.tasks.upload_file_to_gcs" href="#pipelines.rj_escritorio.inea.tasks.upload_file_to_gcs">upload_file_to_gcs</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>